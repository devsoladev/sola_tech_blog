---
title: ES6 개념 다지기
date: 2023-05-23
description: JavaScript ES6의 핵심 개념을 정리해보자.
---

<br />
<br />

## var & let & const

### var

var는 변수를 선언할 때 사용하는 키워드이다. ES5까지는 모든 변수가 var 키워드로 정의되었다. 그러나 var 키워드로 선언한 변수는 몇몇 문제점을 갖고 있다. 우선 var 키워드로 선언한 변수는 중복으로 선언할 수 있기 때문에 초기화문의 유무에 따라 다르게 동작한다. 만약 같은 이름의 변수가 이미 선언되어 있는 것을 모르고 변수를 중복으로 선언하고 값까지 할당했다면, 의도치 않게 이전에 선언된 변수의 값이 변경되는 사이드 이펙트가 발생한다.<br />
또한 var 키워드로 선언한 변수는 오직 '함수 레벨 스코프'만 지역 스코프로 인정하기 때문에 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 안에 있어도 전역 변수가 된다. 따라서 의도치 않게 전역 변수가 중복으로 선언될 수 있다. <br />
마지막으로 var 키워드로 변수를 선언하면 '변수 호이스팅'이 발생하게 된다. 변수 호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있어 오류가 발생할 여지가 많다. 호이스팅 개념에 대해서는 아래에서 더 자세히 살펴보도록 하겠다.<br />

<br />

### let

var의 여러 문제점을 보완하기 위해 ES6부터 도입된 변수 선언 키워드이다. let 키워드로 선언한 변수는 중복 선언이 불가능하다. 또한 모든 코드 블록을 지역 스코프로 인정하는 '블록 레벨 스코프'를 가지므로 같은 이름이더라도 전역에서 선언된 변수와 코드 블록 내에서 선언된 변수는 별개로 인식된다.<br />
let 키워드로 선언한 변수는 '선언 단계'와 '초기화 단계'가 분리되어 진행되기 때문에 '변수 호이스팅'이 발생하지 않는 것처럼 동작한다. 즉, 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간인 '일시적 사각지대'가 존재하여 호이스팅되지 않는 것이다.

### const

상수를 선언하기 위해 ES6에서 도입된 변수 선언 키워드이다. let 키워드와 마찬가지로 블록 레벨 스코프를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작한다. const 키워드로 선언한 변수는 반드시 '선언'과 '초기화'가 동시에 이루어져야 하며 값을 재할당 할 수 없다. const를 사용하여 상수를 선언하면 유지보수에 용이하다.

<br />
따라서, 변수를 선언할 때는 우선 const 키워드를 사용하고, 재할당이 필요한 경우에 한하여
let 키워드를 사용하는 것이 좋다.

<br />
<br />

## Hoisting

자바스크립트에서 변수 또는 함수가 어느 위치에 선언되었는지와 관계 없이 최상단으로 끌어 올려지는 현상을 뜻한다.

- 변수 호이스팅
  변수 선언문이 코드의 최상단으로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징을 '변수 호이스팅'이라고 한다. 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든지 상관없이 다른 코드보다 일찍 실행되므로 어디서든지 변수를 참조할 수 있게 된다. 변수 선언은 소스코드가 한 줄씩 순차적으로 실행되는 시점인 런타임(runtime)이 아니라 '그 이전 단계'에서 먼저 실행된다.

- 함수 호이스팅
  함수 선언문이 코드의 최상단으로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징을 '함수 호이스팅'이라고 한다. <u>함수 선언문</u>으로 정의한 함수와 <u>함수 표현식</u>으로 정의한 함수의 생성 시점은 서로 다르다. <u>함수 선언문</u>은 전체가 호이스팅되는 반면, <u>함수 표현식</u>은 변수 선언부만 호이스팅된다. <u>함수 표현식</u>은 함수 리터럴을 변수에 할당한 것으로 변수를 선언한 것과 동일하게 동작하기 때문에 '변수 호이스팅'이 발생한다.

<br />
<br />

## this

this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-referencing variable)이다.
this 키워드를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티(property)나 메서드(method)를 참조할 수 있다.<br />
자바스크립트에서 this는 호출자가 누구인지에 따라 바인딩되는 값이 달라진다.

### 호출 방식에 따른 this binding

- 일반 함수를 호출하는 경우 => 전역 객체 바인딩
- 메서드를 호출하는 경우 => 메서드를 호출한 객체 바인딩
- 생성자 함수를 호출하는 경우 => 생성자 함수가 생성할 인스턴스 바인딩
- apply/call/bind 메서드를 통해 간접 호출하는 경우 => 명시적 바인딩

<br />
<br />

## Callback function

콜백 함수는 다른 코드의 인자로 넘겨줌으로써 제어권을 함께 위임한 함수를 뜻한다. 콜백 함수를 넘겨받는 코드는 자체적인 내부 로직에 의해 콜백 함수를 적절한 시점에 실행한다. 콜백 함수는 함수형 프로그래밍 패러다임뿐만 아니라 이벤트 처리, Ajax 통신 등 비동기 처리에 많이 활용되는 패턴이다.<br />
콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인가에 대한 제어권을 가진다. 콜백 함수를 호출할 때 인자로 넘겨줄 값들과 그 순서가 정해져 있기 때문에 반드시 순서를 따라서 인자를 넘겨주어야 한다.

### Callback Hell

콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 지나치게 깊어지는 현상을 '콜백 지옥'이라고 부른다. 주로 비동기 작업을 수행할 때 발생할 가능성이 높다. 콜백 지옥은 가독성이 매우 떨어질 뿐만 아니라, 디버깅이 어려워 유지보수에 좋지 않다.

<br />
<br />

## Promise

콜백 패턴의 단점을 보완하기 위해 ES6에 도입된 표준 빌트인 객체이다. 프로미스 생성자 함수는 비동기 처리를 수행할 콜백 함수를 인수로 전달 받는다. 전달 받은 콜백 함수는 'resolve' 와 'reject' 함수를 인수로 전달 받는다.<br />
프로미스 생성자 함수가 인수로 전달 받은 콜백 함수 내부에서 비동기 처리를 수행하며, 성공하면 resolve 함수가, 실패하면 reject 함수를 호출한다.

### Promise 상태 정보

- 대기(pending): 비동기 처리가 아직 수행되지 않은 상태
- 이행(fulfilled): 비동기 처리가 성공한 상태
- 거부(rejected): 비동기 처리가 실패한 상태

### Promise 후속 처리 메서드

- then
  - 프로미스가 fulfilled인 상태가 되면 호출되는 콜백 함수와 rejected인 상태가 되면 호출되는 콜백 함수를 인수로 받는다.
- catch
  - 프로미스가 rejected인 상태일 때만 인수로 받은 콜백 함수가 호출된다.
- finally

  - 프로미스의 성공 또는 실패와 상관 없이 인수로 받은 콜백 함수가 호출된다.

  ### Promise Chaining

  프로미스의 후속 처리 메서드는 새로운 프로미스 객체를 반환하기 때문에 연속적으로 호출할 수 있다. 프로미스 체이닝을 통해 비동기 처리 결과를 전달 받아서 후속 처리하면 콜백 지옥을 방지할 수 있다. 그러나 프로미스도 여전히 콜백 패턴에 기반하기 때문에 가독성이 다소 떨어진다.

<br />
<br />

## async/await

비동기 처리를 마치 '동기적'으로 처리하는 것처럼 구현하기 위해 ES2017에 도입된 비동기 처리 패턴이다. async/await은 프로미스를 기반으로 동작하며, 프로미스의 후속 처리 메서드 없이 동기 처리처럼 프로미스가 처리 결과를 반환하도록 할 수 있다.

### async function

async 함수는 async 키워드를 사용하여 정의하며 언제나 프로미스 객체를 반환한다.

### await keyword

await 키워드는 프로미스의 비동기 처리가 수행될 때까지 기다리다가 수행이 완료되면 프로미스가 resolve한 값을 반환한다. await 키워드는 반드시 프로미스 앞에 사용해야 한다.

### error handling

콜백 함수를 인수로 전달받는 비동기 함수와 달리, 프로미스를 반환하는 비동기 함수는 명시적으로 호출할 수 있기 때문에 async/await에서는 try-catch문을 사용하여 에러 처리를 할 수 있다.

<br />
<br />
<br />

### Ref

- [https://www.youtube.com/playlist?list=PLv2d7VI9OotTVOL4QmPfvJWPJvkmv6h-2](https://www.youtube.com/playlist?list=PLv2d7VI9OotTVOL4QmPfvJWPJvkmv6h-2)
- 이웅모, ⌜모던 자바스크립트 Deep Dive⌟, 위키북스, 2020
